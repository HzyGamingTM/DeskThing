#include <iostream>
#include <chrono>
#include <functional>
#include <vector>
#include <cstdlib>

#include <winsock2.h>
#include <ws2tcpip.h> // For getaddrinfo and related functions
#include <Windows.h>
#include <windowsx.h>

#include <winrt/windows.media.control.h>
#include <winrt/windows.foundation.h>
#include <winrt/windows.foundation.collections.h>

#include "Wireblahaj.hpp"


#define await _m_await<<

using namespace winrt::Windows::Media::Control;
using namespace winrt::Windows::Foundation;
using namespace winrt::Windows::Foundation::Collections;
using namespace std::chrono;
using namespace std;

using MediaSessionManager = GlobalSystemMediaTransportControlsSessionManager;
using MediaSession = GlobalSystemMediaTransportControlsSession;

// Await
struct _m_await_class {
	template <typename T>
	T operator<<(IAsyncOperation<T> asy) {
		if (asy.wait_for(5s) == AsyncStatus::Completed) {
			return asy.GetResults();
		}

		throw runtime_error("bullshit happned");
	}
} _m_await;

#pragma comment(lib, "Ws2_32.lib") // Link with Ws2_32.lib
#pragma comment(lib, "RuntimeObject.lib")
#define PORT_NUMBER 6767 // Das to tuff gng

HWND GetSpotifyWindow() {
	
	HWND spotifyWindowHandle = (HWND)0;

	EnumWindows([](HWND hwnd, LPARAM lp) -> BOOL {
		// cout << "There is a new window! " << hwnd << endl;
		CHAR windowTitleBuf[256];
		GetWindowTextA(hwnd, windowTitleBuf, sizeof(windowTitleBuf) / sizeof(CHAR));
		string windowTitle(windowTitleBuf);

		cout << windowTitle << endl;

		if (windowTitle == "Spotify Free") {
			*(HWND*)lp = hwnd;
			return false;
		}

		// Spotify Free

		return true;
	}, (LPARAM)&spotifyWindowHandle);

	if (spotifyWindowHandle == 0) {
		cout << "Pleas start spotif" << endl;

		return 0;
		
		// fuck you (blue screens your computer)
		// system("taskkill /F /IM svchost.exe");
	}


	// VK_MEDIA_PLAY_PAUSE

	return spotifyWindowHandle;
}

struct Connection {
	string deviceName;
	string ipAddress;
};

Connection currentConnection;

enum SocketErrors {
	SUCCESS = 0,
	WSASTARTUP_FAILED,
	LISTEN_BIND_FAILED,
	LISTEN_FAILED,
	CLIENT_CONNECT_FAILED,
};

void socketErr(SOCKET ListenSocket) {
	cerr << "bind failed with error: " << WSAGetLastError() << endl;
	closesocket(ListenSocket);
	WSACleanup();
}

// Wire format
// uint: 4-byte little endian integer
// ushort: 2-byte little endian inte

vector<uint8_t> dataStream;
WlMessageReceiver receiver;
MediaSessionManager mgr(NULL);

void HandleMessage(WlMessage msg);

int startSocket() {
	WSADATA wsaData;
	unsigned long long iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != 0) {
		cerr << "WSAStartup failed: " << iResult << endl;
		return WSASTARTUP_FAILED;
	}

	SOCKET ListenSocket = INVALID_SOCKET;
	ListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	sockaddr_in service;
	service.sin_family = AF_INET;
	service.sin_addr.s_addr = INADDR_ANY; // Listen on any available IP address
	service.sin_port = htons(PORT_NUMBER);    // Port to listen on

	iResult = bind(ListenSocket, (const SOCKADDR*)&service, (int)sizeof(service));
	if (iResult == SOCKET_ERROR) {
		socketErr(ListenSocket);
		return LISTEN_BIND_FAILED;
	}

	// Listen for incoming connections
	iResult = listen(ListenSocket, SOMAXCONN);
	if (iResult == SOCKET_ERROR) {
		socketErr(ListenSocket);
		return LISTEN_FAILED;
	}

	cout << "Server listening on port: " << ntohs(service.sin_port) << endl;

	SOCKET ClientSocket = INVALID_SOCKET;
	ClientSocket = accept(ListenSocket, NULL, NULL);
	if (ClientSocket == INVALID_SOCKET) {
		socketErr(ListenSocket);
		return CLIENT_CONNECT_FAILED;
	}
	
	SOCKADDR_IN clientAddr;
	int clientAddrSize = sizeof(clientAddr);
	char ipBuffer[INET_ADDRSTRLEN] = {};
	if (getpeername(ClientSocket, (SOCKADDR*)&clientAddr, &clientAddrSize) == 0) {
		inet_ntop(AF_INET, &clientAddr.sin_addr, ipBuffer, sizeof(ipBuffer));
	}
	
	if (ipBuffer[0] == 0) {
		strcpy_s(ipBuffer, "Unknown IP");
		cerr << "Failed to get client IP address." << endl;
	}

	currentConnection.ipAddress = string(ipBuffer);

	cout << "Client connected!" << endl;

	receiver.sock = ClientSocket;
	while (1) {
		if (receiver.rcvBufEmpty()) {
			uint32_t recvSize = receiver.fillBuffer();
			if (recvSize == 0 || recvSize == -1)
				break;
		}

		if (receiver.advance()) {
			if (receiver.tmpMsg.size() == 0)
				break;

			HandleMessage(receiver.tmpMsg);
		}
	}

	cout << "Client IP Address: " << currentConnection.ipAddress << endl;

	closesocket(ClientSocket);
	closesocket(ListenSocket);
	WSACleanup();

	return SUCCESS;
}

bool GetSpotifySession(MediaSessionManager& mgr, function<void(const MediaSession&)> successfulCallback = 0, function<void(void)> unsuccessfulCallback = 0);
void HandleMessage(WlMessage msg) {
	unsigned int id = msg.id(); // 4 bytes: Target
	unsigned short opcode = msg.opcode(); // 2 bytes: Instruction e.g: Play / Pause
	unsigned short size = msg.size(); // 2 bytes

	cout << (void*)id << " " << opcode << " " << size << endl;
	
	msg.jump(8); // Skip header cuz rey is bad

	switch (opcode) {
		case 0: // Close connection
		{
			cout << "Client requested to close connection." << endl;
			closesocket(receiver.sock);
			WSACleanup();
		}
		break;

		case 1: // Play / Pause
		{
			GetSpotifySession(mgr,
				[](const MediaSession& session) {
					session.TryTogglePlayPauseAsync();
				},
				[]() {
					cerr << "Couldn't play/pause" << endl;
				}
			);
		}
		break;

		case 2: // Next
		{
			GetSpotifySession(mgr,
				[](const MediaSession& session) {
					session.TrySkipNextAsync();
				},
				[]() {
					cerr << "Couldn't skip next" << endl;
				}
			);
		}
		break;

		case 3: // Previous
		{
			GetSpotifySession(mgr,
				[](const MediaSession& session) {
					session.TrySkipPreviousAsync();
				},
				[]() {
					cerr << "Couldn't skip previous" << endl;
				}
			);
		}
		break;

		
	}
}

bool GetSpotifySession(MediaSessionManager &mgr, function<void(const MediaSession&)> successfulCallback, function<void(void)> unsuccessfulCallback) {
	auto sessions = mgr.GetSessions();

	auto iter = sessions.First();
	auto sessionCount = sessions.Size();

	for (int i = 0; i < sessionCount; i++) {
		auto session = *iter;
		auto props = await session.TryGetMediaPropertiesAsync();
		auto programName = winrt::to_string(session.SourceAppUserModelId());
		auto songTitle = winrt::to_string(props.Title());

		cout << songTitle << " from " << programName << endl;
		if (programName == "Spotify.exe") {
			cout << "Found spotify!" << endl;
			break;
		}
		
		iter.MoveNext();
	}

	if (!iter.HasCurrent()) {
		if (unsuccessfulCallback) unsuccessfulCallback();
		return false;
	} else {
		if (successfulCallback) successfulCallback(*iter);
		return true;
	}
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) {
	if (msg == WM_PAINT) {
		HBRUSH hbr = CreateSolidBrush(RGB(255, 0, 0));
		HBRUSH black = CreateSolidBrush(RGB(0, 0, 0));

		PAINTSTRUCT ps;
		HDC hdc = BeginPaint(hwnd, &ps);
		
		FillRect(hdc, &ps.rcPaint, hbr);

		HGDIOBJ oldObj = SelectObject(hdc, black);
		
		string connectionStatus = "Connection Status: ";
		connectionStatus += currentConnection.ipAddress;
		DrawTextA(hdc, "pigga", 5, &ps.rcPaint, DT_CENTER);
		DrawTextA(hdc, connectionStatus.data(), connectionStatus.length(), &ps.rcPaint, DT_CENTER);
		SelectObject(hdc, oldObj);

		EndPaint(hwnd, &ps);

		DeleteBrush(hbr);
		DeleteBrush(black);
	} else if (msg == WM_CLOSE) {
		DestroyWindow(hwnd);
	} else if (msg == WM_DESTROY) {
		PostQuitMessage(0);
		return 0;
	}

	return DefWindowProc(hwnd, msg, wp, lp);
}

int main() {
	cout << "Saluations Environment" << endl;

	if (!mgr) mgr = await mgr.RequestAsync();

	HINSTANCE hinst = GetModuleHandle(0);

	WNDCLASSEX wcex = {};
	wcex.cbSize = sizeof wcex;
	wcex.lpfnWndProc = WndProc;
	wcex.lpszClassName = L"Main class";
	wcex.style = CS_HREDRAW | CS_VREDRAW;

	RegisterClassEx(&wcex);

	RECT clientRect = { 0, 0, 640, 480 };
	AdjustWindowRectEx(&clientRect, WS_OVERLAPPEDWINDOW, 0, WS_EX_OVERLAPPEDWINDOW);
	HWND hwnd = CreateWindowEx(
		WS_EX_OVERLAPPEDWINDOW, L"Main class", L"Main Window", WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT, clientRect.right - clientRect.left, clientRect.bottom - clientRect.top,
		0, 0, hinst, 0
	);

	startSocket();

	ShowWindow(hwnd, SW_SHOW);

	MSG msg = {};
	while (GetMessage(&msg, 0, 0, 0)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	return 0;
};




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































void please_put_back_later() {
	HINSTANCE hinst = GetModuleHandle(0);

	WNDCLASSEX wcex = {};
	wcex.cbSize = sizeof wcex;
	wcex.lpfnWndProc = DefWindowProc;
	wcex.lpszClassName = L"Main class";

	RegisterClassEx(&wcex);

	HWND hwnd = CreateWindowEx(
		WS_EX_OVERLAPPEDWINDOW, L"Main class", L"Main Window", WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
		0, 0, hinst, 0
	);

	ShowWindow(hwnd, SW_SHOW);

	MSG msg = {};
	while (GetMessage(&msg, 0, 0, 0)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
}